/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooWimpSpectrum.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(RooWimpSpectrum) 

 RooWimpSpectrum::RooWimpSpectrum(const char *name, const char *title, 
                        RooAbsReal& _Enr,
                        RooAbsReal& _mWimp,
                        RooAbsReal& _v0,
                        RooAbsReal& _ve,
                        RooAbsReal& _vesc,
                        RooAbsReal& _rho,
                        RooAbsReal& _c,
                        RooAbsReal& _r,
                        RooAbsReal& _a,
                        RooAbsReal& _s,
                        RooAbsReal& _delta,
                        RooAbsReal& _beta) :
   RooAbsPdf(name,title), 
   Enr("Enr","Enr",this,_Enr),
   mWimp("mWimp","mWimp",this,_mWimp),
   v0("v0","v0",this,_v0),
   ve("ve","ve",this,_ve),
   vesc("vesc","vesc",this,_vesc),
   rho("rho","rho",this,_rho),
   c("c","c",this,_c),
   r("r","r",this,_r),
   a("a","a",this,_a),
   s("s","s",this,_s),
   delta("delta","delta",this,_delta),
   beta("beta","beta",this,_beta)
 { 
 } 


 RooWimpSpectrum::RooWimpSpectrum(const RooWimpSpectrum& other, const char* name) :  
   RooAbsPdf(other,name), 
   Enr("Enr",this,other.Enr),
   mWimp("mWimp",this,other.mWimp),
   v0("v0",this,other.v0),
   ve("ve",this,other.ve),
   vesc("vesc",this,other.vesc),
   rho("rho",this,other.rho),
   c("c",this,other.c),
   r("r",this,other.r),
   a("a",this,other.a),
   s("s",this,other.s),
   delta("delta",this,other.delta),
   beta("beta",this,other.beta)
 { 
 } 



 Double_t RooWimpSpectrum::evaluate() const 
 { 
   const double xe = ve/v0;
   const double xesc = vesc/v0;

   double Z = 54.;
   double A = 131.;

   // unit conversion factors 
   const double c_mass = 5.6085e+26; // [kg] -> [GeV/c2]
   const double c_time = 8.64e+04; // [days] -> [s]
   const double c_sigma = 8.98755e+09; // conversion factor for [cm] -> [km] & [km/s]->[c] & [GeV]->[keV]
   const double c_pb = 1.e-36; // [cm2] -> [pb]
   
  // neutron mass
   double m_n = 0.939565379; // GeV/c2
   
   // Mass of nucleus, Xe-131
   double M = 121.9107; // [GeV/c2]
   
   // WIMP-neutron reduced mass
   double mu_ne = mWimp*m_n/(mWimp+m_n);
   
   // WIMP-nucleus reduced mass
   double mu = mWimp*M/(mWimp+M);
   
   // Momentum transfer and nuclear radius for form factor
   double q_fm = sqrt(2.*M*(Enr*1e-06))/0.197; // Conversion of q from [GeV/c] to [fm]^-1 (arXiv:0608035v2)
   
   // Xe-131 nuclear radius params, arXiv:0608035v2
   //double R = sqrt(pow(c, 2.) + 7./3.*pow(TMath::Pi()*a,2.) - 5*pow(s,2.)); // [fm]

   // Helm form factor from Lewin and Smith
   double R = sqrt(pow(r,2.) - 5*pow(s,2.)); // [fm]

   // Nuclear form factor
   double F_Er = 1.;
   if (q_fm*R > 0.)
     F_Er = pow( 3.*(sin(q_fm*R)-q_fm*R*cos(q_fm*R))/ pow(q_fm*R, 3.) , 2. )*TMath::Exp(-pow(q_fm*s, 2.));

   // Try using relations from arXiv:hep-ph/0608035v2, modulo sig_xs - include that in nSig
   double dsigma_dE = ( c_mass * c_time * c_sigma * c_pb
		       *(0.5*rho/(mWimp*pow(mu_ne,2))) *pow(A,2) * F_Er); 


   //Velocity component
   double xi_E = 0.;   

   // From arxiv:1005.0579v3
   double vmin = (TMath::C()*1.e-03) * sqrt(0.5/(M*(Enr*1e-06))) * (M*(Enr*1e-06)/mu + (delta*1e-06)); // [km/s]
   double xmin = vmin/v0;


   // Integration of velocity component  (arxiv:1005.0579v3)
   // Take out factor of pi^1.5*v0^2 that would be divided out in xi_E
   double N = v0*(TMath::Erf(xesc) - 4./sqrt(TMath::Pi())*TMath::Exp(-xesc*xesc)*(0.5*xesc+beta*pow(xesc,3.)/3.));

//   // Lewin and Smith   
//     xi_E = 0.5/(N*xe) 
//       * ( TMath::Erf(xmin+xe) - TMath::Erf(xmin-xe) - 4.*xe/sqrt(TMath::Pi())*TMath::Exp(-xesc*xesc)*(1+beta*(xesc*xesc - xe*xe/3. - xmin*xmin)) );
   
   if( (xe+xmin) < xesc )
     xi_E = 0.5/(N*xe) 
       * ( TMath::Erf(xmin+xe) - TMath::Erf(xmin-xe) - 4.*xe/sqrt(TMath::Pi())*TMath::Exp(-xesc*xesc)*(1+beta*(xesc*xesc - xe*xe/3. - xmin*xmin)) );
   else if( xmin > fabs(xesc-xe) && xmin < (xe+xesc) )
     xi_E = 0.5/(N*xe) 
       * ( TMath::Erf(xesc) + TMath::Erf(xe-xmin) - 2./sqrt(TMath::Pi())*TMath::Exp(-xesc*xesc)*(xesc + xe - xmin - beta/3.*(xe-2.*xesc-xmin)*pow(xesc+xe-xmin,2.)) );
   else if( xe>(xmin+xesc) )
     xi_E = 1./(v0*xe);


   return dsigma_dE*xi_E;
 } 



